{
  "name": "deco",
  "version": "0.12.3",
  "description": "Compose modular decorators to build constructors.  Your Node.js code will never have been as organized, reusable, and pluggable.",
  "main": "index.js",
  "scripts": {
    "test": "mocha --bail --timeout 5000"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/wprl/deco.git"
  },
  "keywords": [
    "decorator",
    "decorate",
    "pattern",
    "mixin",
    "organize",
    "partials",
    "partial classes"
  ],
  "author": {
    "name": "William Riley-Land"
  },
  "license": "MIT",
  "dependencies": {
    "requireindex": "~1.1.0"
  },
  "devDependencies": {
    "mocha": "~1.18.2",
    "expect.js": "~0.3.1",
    "express": "~3.5.1"
  },
  "readme": "![deco.js](https://raw.githubusercontent.com/wprl/deco/master/deco.jpeg \"deco.js\")\n=======\nCompose modular decorators to build constructors.  You're Node.js code will never have been as organized, reusable, and pluggable.\n\nSummary\n-------\n\n * Compose decorators into constructors and modules\n * Supports public, private, and protected instance members\n * Build constructors & modules in a way similar to partial classes\n * Uses Node's built-in inherits functionality\n * Easily plug your constructors at runtime with additional decorators\n\nUsage Overview\n--------------\n\nThe main functionality is provided by the `deco()` function.  It builds constructors.\n\n    var deco = require('deco');\n\n    var Constructor = deco();\n    var o = Constructor();\n\nInheritence can be achieved by the `inherit` constructor method.  This is shorthand for the built-in `util.inherits(Constructor, super_)`.  The super constructor will be called on the object before decoration.\n\n    Constructor.inherit(super_);\n\nTo provide a constructor with decorators, use the `decorators` constructor method.\n\n    Constructor.decorators(function () {\n      this.cheese = 'Shropshire Blue';\n    });\n\n    var snack = Constructor();\n    // `snack.cheese` will be \"Shropshire Blue.\"\n\nDecorators can also be supplied when the constructor is built.\n\n    var Ale = deco(function () {\n      this.created = new Date();\n    });\n\nArrays of decorator functions are also allowed.\n\n    var Lager = deco([ f1, f2 ]);\n\nDeco.js provides a better way to provide default constructor options.\n\n    Ale.defaults({\n      yeast: 'Dry English Ale',\n      hops: 'Nugget'\n    });\n\n    Ale.decorators(function (options) {\n      // When `stout` is being created:\n      // `options.yeast` will be set to \"Nottingham.\"\n      // `options.hops` will have the default value of \"Nugget.\"\n    });\n\n    var stout = Ale({ yeast: 'Nottingham' });\n\n\nLoad a directory of decorator files into a constructor by sending in a path.\n\n    var Composed = deco(__dirname);\n\nOr to only load specific files:\n\n    Composed = deco(__dirname, [ 'decorator1', 'decorator2' ]);\n\nDeco.js constructors are themselves decorators!  Use them to group decorators for use in other constructors, or call them directly on existing objects.\n\n    var AnotherConstructor = deco([ Composed, function () { /* ... */ }]);\n\n    // also...\n\n    var app = express();\n    Composed.call(app);\n\nYou can have constructors use a factory method, instead of using prototypal inheritence.\n\n    var ExpressConstructor = deco();\n    ExpressConstructor.factory = express;\n    // `ExpressConstructor()` will create the object to be decorated by\n    // calling the factory function e.g. `express()`.\n\nIf you are setting a constructor as a property of another object, it will be interpreted as a method call and the runtime will pass the containing object in as `this`.  Deco will handle this situation for you if you designate the container.\n\n    var collected = { Constructor1: deco(), Constructor2: deco() };\n    collected.Constructor1.container(collected);\n    collected.Constructor2.container(collected);\n\n    var o = collected.Contructor1();\n\nProtected instance members are passed into your decorators by deco.  Each constructed object has internal access to protected data, but it is hidden from outside code.\n\n    var Bee = deco(function (options, protect) {\n      protect.poisoned = true;\n    });\n\n    Bee.decorators(function (options, protect) {\n      if (protect.poisoned) this.behavior = 'erratic';\n    });\n\n    var b = Bee();\n    // `b.behavior` is set to \"erratic.\"\n    // `protect.poisoned` is not accessible in this scope, only to decorators.\n\nTo overwrite constructor options, use the protected `options` instance method.  The altered options will be merged with the constructor's defaults.\n\n    var FortifiedWine = deco(function (optionsString, protect) {\n      protect.options({ name: optionsString });\n    });\n\n    FortifiedWine.decorators(function (options) {\n      this.name = options.name;\n    });\n\n    var quaff = FortifiedWine('sherry');\n    // `quaff.name` will be set to \"sherry.\"\n\nContact\n-------\n\n * http://kun.io/\n * @wprl\n\n&copy; 2014 William P. Riley-Land\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/wprl/deco/issues"
  },
  "_id": "deco@0.12.3",
  "_from": "deco@^0.12.3"
}
